<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>[转]promises 很酷，但很多人并没有理解就在用了 | SHANG Blog</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="SHANG Blog">
    <meta name="author" content="xinshangshangxin">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="SHANG Blog" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="javascript:;" class="popup-trigger" title="Search"><span class="search-icon"></span>SEARCH</a></li>
            

            <li><a href="/tags" class="animsition-link" title="archive">TAGS</a></li>

            <!-- <li><a href="/about.html" class="animsition-link" title="about">About</a></li> -->
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.jpeg" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
                            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
                            
                                <li><a href="javascript:;" class="popup-trigger" title="Search"><span class="search-icon"></span>Search</a></li>
                            

                            <li><a href="/tags" class="animsition-link" title="archive">tags</a></li>

                            <!-- <li><a href="/about.html" class="animsition-link" title="about">About</a></li> -->
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
                            
                            <li><a href="https://github.com/xinshangshangxin" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            
                            
                            
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2015-09-29T05:55:30.000Z" itemprop="datePublished">
          2015年09月29日
      </time>
    
    
    | 
    <a href='/tags/js/'>js</a>,
    
    <a href='/tags/promise/'>promise</a>
    
    
</span>
                <h1 style="margin-top: 0!important">[转]promises 很酷，但很多人并没有理解就在用了</h1>
            </div>
        </div>
        <div class="col-md-12">
                <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#新手错误No-1：回调金字塔"><span class="post-toc-number">1.</span> <span class="post-toc-text">新手错误No.1：回调金字塔</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#新手错误3：忘记添加catch-方法"><span class="post-toc-number">2.</span> <span class="post-toc-text">新手错误3：忘记添加catch()方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#新手常见错误＃5-使用其副作用而不是return"><span class="post-toc-number">3.</span> <span class="post-toc-text">新手常见错误＃5:使用其副作用而不是return</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-返回另一个promise对象"><span class="post-toc-number">4.</span> <span class="post-toc-text">1.返回另一个promise对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-返回一个同步的值或者是undefined"><span class="post-toc-number">5.</span> <span class="post-toc-text">2.返回一个同步的值或者是undefined</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-抛出一个同步的错误"><span class="post-toc-number">6.</span> <span class="post-toc-text">3.抛出一个同步的错误</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#进阶错误"><span class="post-toc-number"></span> <span class="post-toc-text">进阶错误</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#进阶错误1：不了解Promise-resolve"><span class="post-toc-number">1.</span> <span class="post-toc-text">进阶错误1：不了解Promise.resolve()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#进阶错误2：cacth-和then-null-…-并不完全相同"><span class="post-toc-number">2.</span> <span class="post-toc-text">进阶错误2：cacth()和then(null, …)并不完全相同</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#进阶错误3：promise-vs-promise-factories"><span class="post-toc-number">3.</span> <span class="post-toc-text">进阶错误3：promise vs promise factories</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#进阶错误4：如果我想要两个promise的结果应当如何做呢？"><span class="post-toc-number">4.</span> <span class="post-toc-text">进阶错误4：如果我想要两个promise的结果应当如何做呢？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#进阶错误5：promise坠落现象"><span class="post-toc-number">5.</span> <span class="post-toc-text">进阶错误5：promise坠落现象</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#解决疑惑"><span class="post-toc-number"></span> <span class="post-toc-text">解决疑惑</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Puzzle＃1"><span class="post-toc-number">1.</span> <span class="post-toc-text">Puzzle＃1:</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Puzzle-2"><span class="post-toc-number">2.</span> <span class="post-toc-text">Puzzle #2</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Puzzle-3"><span class="post-toc-number">3.</span> <span class="post-toc-text">Puzzle #3</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Puzzle-4"><span class="post-toc-number">4.</span> <span class="post-toc-text">Puzzle #4</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#最后再说两句"><span class="post-toc-number"></span> <span class="post-toc-text">最后再说两句</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#参考文档"><span class="post-toc-number"></span> <span class="post-toc-text">参考文档</span></a>
            

      		<p>JavaScript 开发者们，是时候承认了，我们在使用<code>promises</code>的时候，会写出许多有问题的<code>promises</code>代码.但并不是 <code>promises</code>本身有问题，被<a href="https://promisesaplus.com/" target="_blank" rel="external">A+ 标准</a>,定义的<code>promises</code> 是极好的  </p>
<p> 在过去的几年中，笔者看到了很多程序员在调用PouchDB或者其他promise化的API时遇到了很多困难。这让笔者认识到，在JavaScript程序员之中，只有少数人是真正理解了promise规范的。如果你觉得这不可思议，那么考虑下我最近<a href="https://twitter.com/nolanlawson/status/578948854411878400" target="_blank" rel="external">在Twitter上的写的一个比较难的题目</a>：</p>
<p><strong>Q：下面四个使用promise的语句之间的不同点在哪儿？</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> doSomethingElse();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  doSomethingElse();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">doSomething().then(doSomethingElse());</div><div class="line"></div><div class="line">doSomething().then(doSomethingElse);</div></pre></td></tr></table></figure>
<p>如果你知道这个问题的答案，那么恭喜你，你已经是一个promise大师并且可以直接关闭这个网页了。  </p>
<p>但是对于不能回答这个问题的程序员中99.9%的人，别担心，你们不是少数派。没有人能够在笔者的tweet上完全正确的回答这个问题，而且对于第三条语句的最终答案也令我感到震惊，即便我是出题人。  </p>
<p>答案在这篇博文的底部，但是首先，笔者必须先介绍为何promise显得难以理解，为什么我们当中无论是新手或者是很接近专家水准的人都有被promise折磨的经历。同时，笔者也会给出自认为能够快速、准确理解promise的方法。而且笔者确信读过这篇文章之后，理解promise不会那么难了。  </p>
<p>在此之前，我们先了解一下有关promise的一些基本设定。  </p>
<p><strong><code>promise</code>从哪里来？</strong></p>
<p>如果你读过有关<code>promise</code>的文章，你会发现文章中一定会提到回调深坑，不说别的，在视觉上，回调金字塔会让你的代码最终超过屏幕的宽度。<br><code>promise</code>是能够解决这个问题的，但是它解决的问题不仅仅是缩进。在讨论到如何解决回调金字塔问题的时候，我们遇到真正的难题是回调函数剥夺了程序员使用<code>return</code>和<code>throw</code>的能力。而程序的执行流程的基础建立于一个函数在执行过程中调用另一个函数时产生的副作用。(译者注：个人对这里副作用的理解是，函数调用函数会产生函数调用栈，而回调函数是不运行在栈上的，因此不能使用<code>return</code>和<code>throw</code>)。</p>
<p>事实上，回调函数会做一些更邪恶的事情，它们剥夺我们在栈上执行代码的能力，而在其他语言当中，我们始终都能够在栈上执行代码。编写不在栈上运行的代码就像驾驶没有刹车的汽车一样，在你真正需要它之前，你是不会理解你有多需要它。</p>
<p><code>promise</code>被设计为能够让我们重新使用那些编程语言的基本要素：<code>return</code>，<code>throw</code>，栈。在想要使用<code>promise</code>之前，我们首先要学会正确使用它。</p>
<p>新手常见错误</p>
<p>一些人尝试使用漫画的方式解释<code>promise</code>，或者是像是解释名词一样解释它：它表示同步代码中的值，并且能在代码中被传递。</p>
<p>笔者并没有觉得这些解释对理解<code>promise</code>有用。笔者自己的理解是：<code>promise</code>是关于代码结构和代码运行流程的。因此，笔者认为展示一些常见错误，并告诉大家如何修正它才是王道。</p>
<p>扯远一点，对于<code>promise</code>不同的人有不同的理解，为了本文的最终目的，我在这里只讨论<code>promise</code>的官方规范，在较新版本的浏览器会作为<code>window</code>对象的一个属性被暴露出来。然而并不是所有的浏览器都支持这一特性，但是到目前为止有许多对于规范的实现，比如这个有着很嚣张的名字的<code>promise</code>库：<code>lie</code>，同时它还非常精简。</p>
<h3 id="新手错误No-1：回调金字塔"><a href="#新手错误No-1：回调金字塔" class="headerlink" title="新手错误No.1：回调金字塔"></a>新手错误No.1：回调金字塔</h3><p>PouchDB有许多promise风格的API，程序员在写有关PouchDB的代码的时候，常常将promise用的一塌糊涂。下面给出一种很常见的糟糕写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">remotedb.allDocs(&#123;</div><div class="line">  <span class="attr">include_docs</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">attachments</span>: <span class="literal">true</span></div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> docs = result.rows;</div><div class="line">  docs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</div><div class="line">    localdb.put(element.doc).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">      alert(<span class="string">"Pulled doc with id "</span> + element.doc._id + <span class="string">" and added to local db."</span>);</div><div class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (err.status == <span class="number">409</span>) &#123;</div><div class="line">        localdb.get(element.doc._id).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</div><div class="line">          localdb.remove(resp._id, resp._rev).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</div><div class="line"><span class="comment">// et cetera...</span></div></pre></td></tr></table></figure>
<p>你确实可以将promise当做回调函数来使用，但这却是一种杀鸡用牛刀的行为。不过这么做也是可行的。 你可能会认为这种错误是那些刚入行的新手才会犯的。但是笔者在<a href="http://devblog.blackberry.com/2015/05/connecting-to-couchbase-with-pouchdb/" target="_blank" rel="external">黑莓的开发者博客上</a>曾经看到类似的代码。过去的书写回调函数的习惯是很难改变的。</p>
<p>下面给出一种代码风格更好的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">remotedb.allDocs(...).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfAllDocs</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> localdb.put(...);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfPut</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> localdb.get(...);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfGet</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> localdb.put(...);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这就是<code>promise</code>的链式调用，它体现promise的强大之处，每个函数在上一个promise的状态变为resolved的时候才会被调用，并且能够得到上一个promise的输出结果。稍后还有详细的解释。</p>
<p>新手错误2：怎样用<code>forEach()</code>处理<code>promise</code></p>
<p>这个问题是大多数人掌握<code>promise</code>的拦路虎，当这些人想在代码中使用他们熟悉的<code>forEach()</code>方法或者是写一个<code>for</code>循环，亦或是<code>while</code>循环的时候，都会为如何使用<code>promise</code>而疑惑不已。他们会写下这样的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// I want to remove() all docs</span></div><div class="line">db.allDocs(&#123;<span class="attr">include_docs</span>: <span class="literal">true</span>&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">  result.rows.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">row</span>) </span>&#123;</div><div class="line">    db.remove(row.doc);  </div><div class="line">  &#125;);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// I naively believe all docs have been removed() now!</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这段代码的问题在于第一个回调函数实际上返回的是<code>undefined</code>，也就意味着第二个函数并不是在所有的<code>db.remove()</code>执行结束之后才执行。事实上，第二个函数的执行不会有任何延时，它执行的时候被删除的doc数量可能为任意整数。  </p>
<p>这段代码看起来是能够正常工作的，因此这个bug也具有一定的隐藏性。写下这段代码的人设想PouchDB已经删除了这些docs，可以更新UI了。这个bug会在一定几率下出现，或者是特定的浏览器。而且一旦出现，这种bug是很难调试的。</p>
<p>总结起来说，出现这个bug并不是<code>promise</code>的错，这个黑锅应该<code>forEach()/for/while</code>来背。这时候你需要的是<code>Promise.all()</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.allDocs(&#123;<span class="attr">include_docs</span>: <span class="literal">true</span>&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(result.rows.map(<span class="function"><span class="keyword">function</span> (<span class="params">row</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> db.remove(row.doc);</div><div class="line">  &#125;));</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">arrayOfResults</span>) </span>&#123;</div><div class="line">  <span class="comment">// All docs have really been removed() now!</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="新手错误3：忘记添加catch-方法"><a href="#新手错误3：忘记添加catch-方法" class="headerlink" title="新手错误3：忘记添加catch()方法"></a>新手错误3：忘记添加catch()方法</h3><p>这是一个很常见的错误。很多程序员对他们代码中的<code>promise</code>调用十分自信，觉得代码永远不会抛出一个<code>error</code>，也可能他们只是简单的忘了加<code>catch()</code>方法。不幸的是，不加<code>catch()</code>方法会让回调函数中抛出的异常被吞噬，在你的控制台是看不到相应的错误的，这对调试来说是非常痛苦的。</p>
<p>为了避免这种糟糕的情况，我已经养成了在自己的<code>promise</code>调用链最后添加如下代码的习惯：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> anotherPromise();</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> yetAnotherPromise();</div><div class="line">&#125;).catch(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>)); <span class="comment">// &lt;-- this is badass</span></div></pre></td></tr></table></figure>
<p>即使你并不打算在代码中处理异常，在代码中添加catch()也是一个谨慎的编程风格的体现。在某种情况下你原先的假设出错的时候，这会让你的调试工作轻松一些。</p>
<p>新手错误4：使用<code>deferred</code></p>
<p>这类型错误笔者经常看到，在这里我也不想重复它了。简而言之，promise经过了很长一段时间的发展，有一定的历史包袱。JavaScript社区用了很长的时间才纠正了发展道路上的一些错误。在早些时候，jQuery和Angular都在使用’deferred’类型的promise。而在最新的ES6的Promise标准中，这种实现方式已经被替代了，同时，一些Promise的库，比如Q，bluebid，lie也是参照ES6的标准来实现的。</p>
<p>如果你还在代码中使用deferred的话，那么你就是走在错误的道路上了，这里笔者给出一些修正的办法。</p>
<p>首先，绝大多数的库都给出了将第三方库的方法包装成promise对象的方法。<br>举例来说，Angular的(<code>q</code>模块可以使用)<code>q.when()</code>完成这一包装过程。因此，在Angular中，包装PouchDB的promise API的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$q.when(db.put(doc)).then(<span class="comment">/* ... */</span>); <span class="comment">// &lt;-- this is all the code you need</span></div></pre></td></tr></table></figure></p>
<p>另一种方法就是使用暴露给程序员的构造函数。<code>promise</code>的构造函数能够包装那些非<code>promise</code>的API。<br>下面给出一个例子，在该例中将node.js提供的fs.readFile()方法包装成promise。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  fs.readFile(<span class="string">'myfile.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">      <span class="keyword">return</span> reject(err);</div><div class="line">    &#125;</div><div class="line">    resolve(file);</div><div class="line">  &#125;);</div><div class="line">&#125;).then(<span class="comment">/* ... */</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p>为什么这是一种反模式更多的信息可以查看： <a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern" target="_blank" rel="external">the Bluebird wiki page on promise anti-patterns</a>.</p>
</blockquote>
<h3 id="新手常见错误＃5-使用其副作用而不是return"><a href="#新手常见错误＃5-使用其副作用而不是return" class="headerlink" title="新手常见错误＃5:使用其副作用而不是return"></a>新手常见错误＃5:使用其副作用而不是return</h3><p>下面的代码有什么问题？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  someOtherPromise();</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// Gee, I hope someOtherPromise() has resolved!</span></div><div class="line">  <span class="comment">// Spoiler alert: it hasn't.</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Ok，现在是时候讨论所有需要了解的关于<code>promise</code>的知识点了。理解了这一个知识点，笔者提到的一些错误你都不会犯了。</p>
<p>就像我之前说过的，promise的神奇之处在于让我们能够在回调函数里面使用return和throw。但是实践的时候是什么样子呢？</p>
<p>每一个promise对象都会提供一个then方法或者是catch方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// I'm inside a then() function!</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们在这里能做什么呢？有三种事可以做：</p>
<ol>
<li>返回另一个promise；</li>
<li>返回一个同步值（或者undefined</li>
<li>抛出一个同步错误。</li>
</ol>
<p>理解这三种情况之后，你就会理解promise了。</p>
<h3 id="1-返回另一个promise对象"><a href="#1-返回另一个promise对象" class="headerlink" title="1.返回另一个promise对象"></a>1.返回另一个promise对象</h3><p>在有关promise的相关文章中，这种写法很常见，就像上文提到的构成promise链的一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> getUserAccountById(user.id);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</div><div class="line">  <span class="comment">// I got a user account!</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这段代码里面的return非常关键，没有这个return的话，getUserAccountById只是一个普通的被别的函数调用的函数。下一个回调函数会接收到undefined而不是userAccount</p>
<h3 id="2-返回一个同步的值或者是undefined"><a href="#2-返回一个同步的值或者是undefined" class="headerlink" title="2.返回一个同步的值或者是undefined"></a>2.返回一个同步的值或者是undefined</h3><p>返回一个undefined大多数情况下是错误的，但是返回一个同步的值确实是一个将同步代码转化成promise风格代码的好方法。举个例子，现在在内存中有users。我们可以：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</div><div class="line">    <span class="keyword">return</span> inMemoryCache[user.id];    <span class="comment">// returning a synchronous value!</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> getUserAccountById(user.id); <span class="comment">// returning a promise!</span></div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</div><div class="line">  <span class="comment">// I got a user account!</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>第二个回调函数并不关心userAccount是通过同步的方式得到的还是异步的方式得到的，而第一个回调函数即可以返回同步的值又可以返回异步的值。<br>不幸的是，如果不显式调用return语句的话，javaScript里的函数会返回undefined。这也就意味着在你想返回一些值的时候，不显式调用return会产生一些副作用。<br>出于上述原因，笔者养成了一个个人习惯就是在then方法内部永远显式的调用return或者throw。笔者也推荐你这样做。</p>
<h3 id="3-抛出一个同步的错误"><a href="#3-抛出一个同步的错误" class="headerlink" title="3.抛出一个同步的错误"></a>3.抛出一个同步的错误</h3><p>说到throw，这又体现了promise的功能强大。在用户退出的情况下，我们的代码中会采用抛出异常的方式进行处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (user.isLoggedOut()) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'user logged out!'</span>); <span class="comment">// throwing a synchronous error!</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</div><div class="line">    <span class="keyword">return</span> inMemoryCache[user.id];       <span class="comment">// returning a synchronous value!</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> getUserAccountById(user.id);    <span class="comment">// returning a promise!</span></div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</div><div class="line">  <span class="comment">// I got a user account!</span></div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="comment">// Boo, I got an error!</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果用户已经登出的话，catch()会收到一个同步的错误，如果有promise对象的状态变为rejected的话，它还会收到一个异步的错误。catch()的回调函数不用关心错误是异步的还是同步的。</p>
<p>在使用promise的时候抛出异常在开发阶段很有用，它能帮助我们定位代码中的错误。比方说，在then函数内部调用JSON.parse（），如果JSON对象不合法的话，可能会抛出异常，在回调函数中，这个异常会被吞噬，但是在使用promise之后，我们就可以捕获到这个异常了。</p>
<h2 id="进阶错误"><a href="#进阶错误" class="headerlink" title="进阶错误"></a>进阶错误</h2><p>接下来我们讨论一下使用promise的边界情况。</p>
<p>下面的错误笔者将他们归类为“进阶错误”，因为这些错误发生在那些已经相对熟练使用promise的程序员身上。但是为了解决本文开头提出的问题，还是有必要对其进行讨论。</p>
<h3 id="进阶错误1：不了解Promise-resolve"><a href="#进阶错误1：不了解Promise-resolve" class="headerlink" title="进阶错误1：不了解Promise.resolve()"></a>进阶错误1：不了解Promise.resolve()</h3><p>就像之前所说的，promise能够将同步代码包装成异步的形式。然而，如果你经常写出如下的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  resolve(someSynchronousValue);</div><div class="line">&#125;).then(<span class="comment">/* ... */</span>);</div></pre></td></tr></table></figure>
<p>你可以使用Promise.resolve()将上述代码精简。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve(someSynchronousValue).then(<span class="comment">/* ... */</span>);</div></pre></td></tr></table></figure>
<p>在捕获同步异常的时候这个做法也是很有效的。我在编写API的时候已经养成了使用Promise.resolve()的习惯：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">somePromiseAPI</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    doSomethingThatMayThrow();</div><div class="line">    <span class="keyword">return</span> <span class="string">'foo'</span>;</div><div class="line">  &#125;).then(<span class="comment">/* ... */</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>记住，有可能抛出错误的代码都有可能因为错误被吞噬而对你的工作造成困扰。但是如果你用Promise.resolve()包装了代码的话，你永远都可以在代码后面加上catch()。</p>
<p>相同的，使用Promise.reject()可以立即返回一个状态为rejected的promise对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'some awful error'</span>));</div></pre></td></tr></table></figure>
<h3 id="进阶错误2：cacth-和then-null-…-并不完全相同"><a href="#进阶错误2：cacth-和then-null-…-并不完全相同" class="headerlink" title="进阶错误2：cacth()和then(null, …)并不完全相同"></a>进阶错误2：cacth()和then(null, …)并不完全相同</h3><p>笔者提到过过cacth()是then(null, …)的语法糖，因此下面两个代码片段是等价的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">somePromise().catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="comment">// handle error</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">somePromise().then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="comment">// handle error</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>但是，这并不意味着下面的两个代码片段是等价的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> someOtherPromise();</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="comment">// handle error</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> someOtherPromise();</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="comment">// handle error</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果你不理解的话，那么请思考一下如果第一个回调函数抛出一个错误会发生什么？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="comment">// I caught your error! :)</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="comment">// I didn't catch your error! :(</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>结论就是，当使用then(resolveHandler, rejectHandler)，rejectHandler不会捕获在resolveHandler中抛出的错误。</p>
<p>因为，笔者的个人习惯是从不使用then方法的第二个参数，转而使用catch()方法。但是也有例外，就是在笔者写异步的Mocha的测试用例的时候，如果想确认一个错误被抛出的话，代码是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'should throw an error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> doSomethingThatThrows().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'I expected an error!'</span>);</div><div class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    should.exist(err);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>说到测试，将<a href="http://mochajs.org/" target="_blank" rel="external">Mocha</a> 和 <a href="http://chaijs.com/" target="_blank" rel="external">Chai</a> 联合使用是一种很好的测试promise API的方案。</p>
<p>. The <a href="https://github.com/pouchdb/plugin-seed" target="_blank" rel="external">pouchdb-plugin-seed</a> 项目有很多你<a href="https://github.com/pouchdb/plugin-seed/blob/master/test/test.js" target="_blank" rel="external">可以入手的简单的测试。</a></p>
<h3 id="进阶错误3：promise-vs-promise-factories"><a href="#进阶错误3：promise-vs-promise-factories" class="headerlink" title="进阶错误3：promise vs promise factories"></a>进阶错误3：promise vs promise factories</h3><p>某些情况下你想一个接一个的执行一系列promise，这时候你想要一个类似于Promise.all()的方法，但是Proimise.all()是并行执行的，不符合要求。你可能一时脑抽写下这样的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeSequentially</span>(<span class="params">promises</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="built_in">Promise</span>.resolve();</div><div class="line">  promises.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promise</span>) </span>&#123;</div><div class="line">    result = result.then(promise);</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不幸的是，这段代码不会按照你所想的那样执行，那些promise对象里的异步调用还是会并行的执行。原因是你根本不应当在promise对象组成的数组这个层级上操作。对于每个promise对象来说，一旦它被创建，相关的异步代码就开始执行了。因此，这里你真正想要的是一个promise工厂。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeSequentially</span>(<span class="params">promiseFactories</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="built_in">Promise</span>.resolve();</div><div class="line">  promiseFactories.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promiseFactory</span>) </span>&#123;</div><div class="line">    result = result.then(promiseFactory);</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个promise工厂非常简单，它就是一个返回promise对象的函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromiseFactory</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> somethingThatCreatesAPromise();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为什么可以达到目的呢？因为promise工厂只有在调用的时候才会创建promise对象。它和then()方法的工作方式很像，事实上，它们就是一样的东西。</p>
<h3 id="进阶错误4：如果我想要两个promise的结果应当如何做呢？"><a href="#进阶错误4：如果我想要两个promise的结果应当如何做呢？" class="headerlink" title="进阶错误4：如果我想要两个promise的结果应当如何做呢？"></a>进阶错误4：如果我想要两个promise的结果应当如何做呢？</h3><p>很多时候，一个promise的执行是依赖另一个promise的。但是在某些情况下，我们想得到两个promise的执行结果，比方说：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> getUserAccountById(user.id);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</div><div class="line">  <span class="comment">// dangit, I need the "user" object too!</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>为了避免产生回调金字塔，我们可能会在外层作用域存储user对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> user;</div><div class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">  user = result;</div><div class="line">  <span class="keyword">return</span> getUserAccountById(user.id);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</div><div class="line">  <span class="comment">// okay, I have both the "user" and the "userAccount"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的代码能够到达想要的效果，但是这种实现有一点不正式的成分在里面，我的建议是，这时候需要抛开成见，拥抱回调金字塔：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> getUserAccountById(user.id).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</div><div class="line">    <span class="comment">// okay, I have both the "user" and the "userAccount"</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>至少，是暂时拥抱回调金字塔。如果缩进真的成为了你代码中的一个大问题，那么你可以像每一个JavaScript程序员从开始写代码起就被教导的一样，将其中的部分抽出来作为一个单独的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onGetUserAndUserAccount</span>(<span class="params">user, userAccount</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> doSomething(user, userAccount);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onGetUser</span>(<span class="params">user</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> getUserAccountById(user.id).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> onGetUserAndUserAccount(user, userAccount);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">getUserByName(<span class="string">'nolan'</span>)</div><div class="line">  .then(onGetUser)</div><div class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// at this point, doSomething() is done, and we are back to indentation 0</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>随着你的promise代码越来越复杂，你会将越来越多的代码作为函数抽离出来。笔者发现这会促进代码风格变得优美：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">putYourRightFootIn()</div><div class="line">  .then(putYourRightFootOut)</div><div class="line">  .then(putYourRightFootIn)  </div><div class="line">  .then(shakeItAllAbout);</div></pre></td></tr></table></figure>
<p>That’s what promises are all about.</p>
<p>这就是promise的最终目的。</p>
<h3 id="进阶错误5：promise坠落现象"><a href="#进阶错误5：promise坠落现象" class="headerlink" title="进阶错误5：promise坠落现象"></a>进阶错误5：promise坠落现象</h3><p>这个错误我在前文中提到的问题中间接的给出了。这个情况比较深奥，或许你永远写不出这样的代码，但是这种写法还是让笔者感到震惊。 你认为下面的代码会输出什么？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>)).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(result);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果你认为输出的是bar，那么你就错了。实际上它输出的是foo！</p>
<p>产生这样的输出是因为你给then方法传递了一个非函数（比如promise对象）的值，代码会这样理解：then(null)，因此导致前一个promise的结果产生了坠落的效果。你可以自己测试一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="literal">null</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(result);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>让我们回到之前讲解promise vs promise factoriesde的地方。简而言之，如果你直接给then方法传递一个promise对象，代码的运行是和你所想的不一样的。then方法应当接受一个函数作为参数。因此你应当这样书写代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(result);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这次会如我们预期的那样返回bar。</p>
<p>所以要提醒你自己：永远给then()传递一个函数参数。</p>
<h2 id="解决疑惑"><a href="#解决疑惑" class="headerlink" title="解决疑惑"></a>解决疑惑</h2><p>现在我们已经学习了关于promises要知道的所有的东西（或者接近于此），我们应该能够解决我在这篇文章开始时提出的疑惑了。</p>
<p>下面给出前文题目的解答</p>
<h3 id="Puzzle＃1"><a href="#Puzzle＃1" class="headerlink" title="Puzzle＃1:"></a>Puzzle＃1:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> doSomethingElse();</div><div class="line">&#125;).then(finalHandler);</div></pre></td></tr></table></figure>
<p>Answer:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">doSomething</div><div class="line">|-----------------|</div><div class="line">                  doSomethingElse(<span class="literal">undefined</span>)</div><div class="line">                  |------------------|</div><div class="line">                                     finalHandler(resultOfDoSomethingElse)</div><div class="line">                                     |------------------|</div></pre></td></tr></table></figure>
<h3 id="Puzzle-2"><a href="#Puzzle-2" class="headerlink" title="Puzzle #2"></a>Puzzle #2</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  doSomethingElse();</div><div class="line">&#125;).then(finalHandler);</div></pre></td></tr></table></figure>
<p>Answer:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">doSomething</div><div class="line">|-----------------|</div><div class="line">                  doSomethingElse(<span class="literal">undefined</span>)</div><div class="line">                  |------------------|</div><div class="line">                  finalHandler(<span class="literal">undefined</span>)</div><div class="line">                  |------------------|</div></pre></td></tr></table></figure>
<h3 id="Puzzle-3"><a href="#Puzzle-3" class="headerlink" title="Puzzle #3"></a>Puzzle #3</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">doSomething().then(doSomethingElse())</div><div class="line">  .then(finalHandler);</div></pre></td></tr></table></figure>
<p>Answer:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">doSomething</div><div class="line">|-----------------|</div><div class="line">doSomethingElse(<span class="literal">undefined</span>)</div><div class="line">|---------------------------------|</div><div class="line">                  finalHandler(resultOfDoSomething)</div><div class="line">                  |------------------|</div></pre></td></tr></table></figure>
<h3 id="Puzzle-4"><a href="#Puzzle-4" class="headerlink" title="Puzzle #4"></a>Puzzle #4</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">doSomething().then(doSomethingElse)</div><div class="line">  .then(finalHandler);</div></pre></td></tr></table></figure>
<p>Answer:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">doSomething</div><div class="line">|-----------------|</div><div class="line">                  doSomethingElse(resultOfDoSomething)</div><div class="line">                  |------------------|</div><div class="line">                                     finalHandler(resultOfDoSomethingElse)</div><div class="line">                                     |------------------|</div></pre></td></tr></table></figure>
<p>如果这些答案仍然没有讲通，那么我鼓励重新阅读文章，或者去定义doSomething()以及doSomethingElse()然后在你的浏览器中自己尝试。</p>
<p>需要说明的是，在上述的例子中，我都假设doSomething()和doSomethingElse()返回一个promise对象，这些promise对象都代表了一个异步操作，这样的操作会在当前event loop之外结束，比如说有关IndexedDB，network的操作，或者是使用setTimeout。这里给出<a href="http://jsbin.com/tuqukakawo/1/edit?js,console,output" target="_blank" rel="external">JSBin上的示例</a>。</p>
<p>Promises更多的使用说明，请参考我的promise主要用法背忘单。 <a href="https://gist.github.com/nolanlawson/6ce81186421d2fa109a4" target="_blank" rel="external">promise protips cheat sheet</a>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Promise.all is good for executing many promises at once</span></div><div class="line"><span class="built_in">Promise</span>.all([</div><div class="line">  promise1,</div><div class="line">  promise2</div><div class="line">]);</div><div class="line"></div><div class="line"><span class="comment">// Promise.resolve is good for wrapping synchronous code</span></div><div class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (somethingIsNotRight()) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"I will be rejected asynchronously!"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"This string will be resolved asynchronously!"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// execute some promises one after the other.</span></div><div class="line"><span class="comment">// this takes an array of promise factories, i.e.</span></div><div class="line"><span class="comment">// an array of functions that RETURN a promise</span></div><div class="line"><span class="comment">// (not an array of promises themselves; those would execute immediately)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequentialize</span>(<span class="params">promiseFactories</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> chain = <span class="built_in">Promise</span>.resolve();</div><div class="line">  promiseFactories.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promiseFactory</span>) </span>&#123;</div><div class="line">    chain = chain.then(promiseFactory);</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> chain;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Promise.race is good for setting a timeout:</span></div><div class="line"><span class="built_in">Promise</span>.race([</div><div class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    setTimeout(reject, <span class="number">10000</span>); <span class="comment">// timeout after 10 secs</span></div><div class="line">  &#125;),</div><div class="line">  doSomethingThatMayTakeAwhile()</div><div class="line">]);</div><div class="line"></div><div class="line"><span class="comment">// Promise finally util similar to Q.finally</span></div><div class="line"><span class="comment">// e.g. promise.then(...).catch().then(...).finally(...)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">finally</span> (<span class="params">promise, cb</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> promise2 = cb();</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> promise2.then === <span class="string">'function'</span>) &#123;</div><div class="line">      <span class="keyword">return</span> promise2.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> promise2 = cb();</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> promise2.then === <span class="string">'function'</span>) &#123;</div><div class="line">      <span class="keyword">return</span> promise2.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">throw</span> reason;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> reason;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="最后再说两句"><a href="#最后再说两句" class="headerlink" title="最后再说两句"></a>最后再说两句</h2><p>promise是个好东西。如果你还在使用传统的回调函数的话，我建议你迁移到promise上。这样你的代码会更简介，更优雅，可读性也更强。</p>
<p>有这样的观点：promise是不完美的。promise确实比使用回调函数好，但是，如果你有别的选择的话，这两种方式最好都不要用。</p>
<p>尽管相比回调函数有许多优点，promise仍然是难于理解的，并且使用起来很容易出错。新手和老鸟都会经常将promise用的乱七八糟。不过说真的，这不是他们的错，应该甩锅给promise。因为它和我们在同步环境的代码很像，但仅仅是像，是一个优雅的替代品。</p>
<p>在同步环境下，你无需学习这些令人费解的规则和一些新的API。你可以随意使用像return，catch，throw这样的关键字以及for循环。你不需要时刻在脑中保持两个相并列的编程思想。</p>
<p>等待async/await</p>
<p>笔者在了解了ES7中的async和await关键字，以及它们是如何将promise的思想融入到语言本身当中之后，写了这样一篇博文用ES7驯服异步这个猛兽。使用ES7，我们将没有必要再写catch()这样的伪同步的代码，我们将能使用try/catch/return这样的关键字，就像刚开始学计算机那样。</p>
<p>这对JavaScript这门语言来说是很好的，因为到头来，只要没有工具提醒我们，这些promise的反模式会持续出现。</p>
<p>从JavaScript发展历史中距离来说，笔者认为JSLint和JSHint对社区的贡献要大于JavaScript:The Good Parts，尽管它们实际上包含的信息是相同的。区别就在于使用工具可以告诉程序员代码中所犯的错误，而阅读却是让你了解别人犯的错误。</p>
<p>ES7中的async和await关键字的美妙之处在于，你代码中的错误将会成为语法错误或者是编译错误，而不是细微的运行时错误。到了那时，我们会完全掌握promise究竟能做什么，以及在ES5和ES6中如何合理的应用。</p>
<p>更新：已经有人跟我指出Bluebird 3.0能打印出警告来避免我在这篇文章中所鉴定的一些错误。所以在我们还在等待ES7的时候使用Bluebird是另一个很棒的选择。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" target="_blank" rel="external">(英文原文)we-have-a-problem-with-promises</a></li>
<li><a href="http://web.jobbole.com/82601/" target="_blank" rel="external">(中文翻译)promises 很酷，但很多人并没有理解就在用了</a></li>
<li><a href="http://web.jobbole.com/82950/" target="_blank" rel="external">(中文翻译)谈谈使用promise时候的一些反模式</a></li>
</ul>
<hr>
<blockquote>
<p><strong>文章若有纰漏请大家补充指正,谢谢~~</strong><br><a href="http://blog.xinshangshangxin.com">http://blog.xinshangshangxin.com</a> SHANG殇</p>
</blockquote>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    <a class="pull-left" href="/2015/10/03/Agreeing-to-the-Xcode-iOS-license-requires-admin-privileges/" style="float: left;">
        ← Agreeing to the Xcode/iOS license requires admin privileges
    </a>
    
    
    <a class="pull-right" href="/2015/09/20/git文件名大小写敏感/">
        git文件名大小写敏感 →
    </a>
    
</nav>

        <div class="col-md-10 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>


      
      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By xinshangshangxin. All Rights Reserved.
                </p>
                <p>Theme By <a href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/xinshangshangxin" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    
                    
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
            <style>
.local-search-popup {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  padding: 0;
  background: rgba(255, 255, 255, .9);
  color: #333;
  z-index: 9999;
  border-radius: 5px;
  overflow: scroll;
}
#local-search-input {
  width: 100%;
  border: none;
  outline: none;
  border-bottom: 1px solid #151515;
  background-color: initial;
}
.search-result-list {
  list-style: none;
  padding-left: 0;
}
.search-result-list > li {
  margin-top: 15px;
  border-bottom: 1px solid #ddd;
  transition: all ease .3s;
}
.search-result-list > li:hover {
  border-bottom: 1px solid gray;
}
.search-result-title {
  font-size: 16px;
}
.search-result {
  line-height: 20px;
}
.search-keyword {
  font-weight: normal;
  color: #c00;
}

@media (min-width: 890px) {
  .popup-btn-close {
    position: absolute;
    top: 15px;
    left: 35px;
    border: 1px solid #151515;
    padding: 0px 10px;
    border-top-left-radius: 8px;
    cursor: pointer;
    transition: all ease .3s;
  }
  .popup-btn-close:hover {
    background: #151515;
    opacity: .9;
    color: #fff;
  }
}
@media (max-width: 890px) {
  .popup-btn-close {
    font-size: 0;
    position: fixed;
    right: 20px;
    bottom: 50px;
    width: 50px;
    height: 50px;
    background: #fff;
    border-radius: 50%;
    box-shadow: 1px 1px 5px #888;
    cursor: pointer;
  }
  .popup-btn-close::after {
    content: '←';
    color: #151515;
    position: absolute;
    top: 0;
    left: 0;
    font-size: 20px;
    width: 100%;
    height: 100%;
    line-height: 50px;
    text-align: center;
  }
}
</style>

<div class="popup search-popup local-search-popup">
  <span class="popup-btn-close">
    ESC
  </span>
  <div class="container">
    <div class="col-md-8 col-md-offset-2">
      <div class="local-search-header clearfix">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="local-search-input-wrapper">
          <input autocomplete="off" placeholder="Search..." type="text" id="local-search-input">
        </div>
      </div>
      <div id="local-search-result"></div>
    </div>
  </div>
</div>

<script src="/js/ziploader.js"></script>


  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').fadeOut(300);
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $('.popup').fadeIn(300);
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // get search zip version
    $.get('/searchVersion.txt?t=' + (+new Date()), function(res) {
      if (localStorage.getItem('searchVersion') !== res) {
        localStorage.setItem('searchVersion', res);
        initSearchJson();
      }
    });

    function initSearchJson () {
      initLoad(['/search.flv'], {
        loadOptions: {
          success: function(obj) {
            localStorage.setItem('searchJson', obj['search.json'])
          },
          error: function(e) {
            return console.log(e)
          }
        },
        returnOptions: {
          'json': TYPE_TEXT
        },
        mimeOptions:{
          'json':'application/json'
        }
      })
    }


    // search function;
    var searchFunc = function(search_id, content_id) {
      'use strict';

      isfetched = true;
      var datas = JSON.parse(localStorage.getItem('searchJson'));
      console.log(search_id)
      var input = document.getElementById(search_id);
      var resultContent = document.getElementById(content_id);
      var inputEventFunction = function() {
        var searchText = input.value.trim().toLowerCase();
        var keywords = searchText.split(/[\s\-]+/);
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        var resultItems = [];
        if (searchText.length > 0) {
          // perform local searching
          datas.forEach(function(data) {
            var isMatch = false;
            var hitCount = 0;
            var searchTextCount = 0;
            var title = data.title ? data.title.trim() : '';
            var titleInLowerCase = title.toLowerCase();
            var content = data.content ? data.content.trim().replace(/<[^>]+>/g,"") : '';
            var contentInLowerCase = content.toLowerCase();
            var articleUrl = decodeURIComponent(data.url);
            var indexOfTitle = [];
            var indexOfContent = [];
            // only match articles with not empty titles
            keywords.forEach(function(keyword) {
              function getIndexByWord(word, text, caseSensitive) {
                var wordLen = word.length;
                if (wordLen === 0) {
                  return [];
                }
                var startPosition = 0, position = [], index = [];
                if (!caseSensitive) {
                  text = text.toLowerCase();
                  word = word.toLowerCase();
                }
                while ((position = text.indexOf(word, startPosition)) > -1) {
                  index.push({position: position, word: word});
                  startPosition = position + wordLen;
                }
                return index;
              }

              indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
              indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
            });
            if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
              isMatch = true;
              hitCount = indexOfTitle.length + indexOfContent.length;
            }

            // show search results

            if (isMatch) {
              // sort index by position of keyword

              [indexOfTitle, indexOfContent].forEach(function (index) {
                index.sort(function (itemLeft, itemRight) {
                  if (itemRight.position !== itemLeft.position) {
                    return itemRight.position - itemLeft.position;
                  } else {
                    return itemLeft.word.length - itemRight.word.length;
                  }
                });
              });

              // merge hits into slices

              function mergeIntoSlice(text, start, end, index) {
                var item = index[index.length - 1];
                var position = item.position;
                var word = item.word;
                var hits = [];
                var searchTextCountInSlice = 0;
                while (position + word.length <= end && index.length != 0) {
                  if (word === searchText) {
                    searchTextCountInSlice++;
                  }
                  hits.push({position: position, length: word.length});
                  var wordEnd = position + word.length;

                  // move to next position of hit

                  index.pop();
                  while (index.length != 0) {
                    item = index[index.length - 1];
                    position = item.position;
                    word = item.word;
                    if (wordEnd > position) {
                      index.pop();
                    } else {
                      break;
                    }
                  }
                }
                searchTextCount += searchTextCountInSlice;
                return {
                  hits: hits,
                  start: start,
                  end: end,
                  searchTextCount: searchTextCountInSlice
                };
              }

              var slicesOfTitle = [];
              if (indexOfTitle.length != 0) {
                slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
              }

              var slicesOfContent = [];
              while (indexOfContent.length != 0) {
                var item = indexOfContent[indexOfContent.length - 1];
                var position = item.position;
                var word = item.word;
                // cut out 100 characters
                var start = position - 20;
                var end = position + 80;
                if(start < 0){
                  start = 0;
                }
                if (end < position + word.length) {
                  end = position + word.length;
                }
                if(end > content.length){
                  end = content.length;
                }
                slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
              }

              // sort slices in content by search text's count and hits' count

              slicesOfContent.sort(function (sliceLeft, sliceRight) {
                if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                  return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                  return sliceRight.hits.length - sliceLeft.hits.length;
                } else {
                  return sliceLeft.start - sliceRight.start;
                }
              });

              // select top N slices in content

              var upperBound = parseInt('2');
              if (upperBound >= 0) {
                slicesOfContent = slicesOfContent.slice(0, upperBound);
              }

              // highlight title and content

              function highlightKeyword(text, slice) {
                var result = '';
                var prevEnd = slice.start;
                slice.hits.forEach(function (hit) {
                  result += text.substring(prevEnd, hit.position);
                  var end = hit.position + hit.length;
                  result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                  prevEnd = end;
                });
                result += text.substring(prevEnd, slice.end);
                return result;
              }

              var resultItem = '';

              if (slicesOfTitle.length != 0) {
                resultItem += "<li><a target='_blank' href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
              } else {
                resultItem += "<li><a target='_blank' href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
              }

              slicesOfContent.forEach(function (slice) {
                resultItem += "<a target='_blank' href='" + articleUrl + "'>" +
                  "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                  "...</p>" + "</a>";
              });

              resultItem += "</li>";
              resultItems.push({
                item: resultItem,
                searchTextCount: searchTextCount,
                hitCount: hitCount,
                id: resultItems.length
              });
            }
          })
        };
        if (keywords.length === 1 && keywords[0] === "") {
          resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
        } else if (resultItems.length === 0) {
          resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
        } else {
          resultItems.sort(function (resultLeft, resultRight) {
            if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
              return resultRight.searchTextCount - resultLeft.searchTextCount;
            } else if (resultLeft.hitCount !== resultRight.hitCount) {
              return resultRight.hitCount - resultLeft.hitCount;
            } else {
              return resultRight.id - resultLeft.id;
            }
          });
          var searchResultList = '<ul class=\"search-result-list\">';
          resultItems.forEach(function (result) {
            searchResultList += result.item;
          })
          searchResultList += "</ul>";
          resultContent.innerHTML = searchResultList;
        }
      }

      if ('auto' === 'auto') {
        input.addEventListener('input', inputEventFunction);
      } else {
        $('.search-icon').click(inputEventFunction);
        input.addEventListener('keypress', function (event) {
          if (event.keyCode === 13) {
            inputEventFunction();
          }
        });
      }

      // remove loading animation
      $('body').css('overflow', '');

      proceedsearch();
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        $('.sb-close').click();
        searchFunc('local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>


      
</body>
</html>
